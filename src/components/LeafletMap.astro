---
const {
  dataUrl = "/rutas.kml",
  isKml = true,
  center = [20.06, -97.92],
  zoom = 12,
  height = "400px",
} = Astro.props;

const id = `leaflet-${Math.random().toString(36).slice(2, 9)}`;
---

<link rel="stylesheet" href="/leaflet/leaflet.css" />
<div 
  id={id} 
  style={`height:${height}; width:100%`} 
  class="leaflet-map"
  data-url={dataUrl}
  data-is-kml={isKml}
  data-center={JSON.stringify(center)}
  data-zoom={zoom}
></div>

<script>
  import L from 'leaflet';
  import { kml } from '@mapbox/togeojson';

  // Initialize all leaflet maps on the page
  function initMaps() {
    const mapElements = document.querySelectorAll('.leaflet-map');
    
    mapElements.forEach(async (mapEl) => {
      const mapId = mapEl.id;
      const dataUrl = mapEl.getAttribute('data-url') || '/rutas.kml';
      const isKml = mapEl.getAttribute('data-is-kml') !== 'false';
      const centerData = mapEl.getAttribute('data-center') || '[20.06, -97.92]';
      const center = JSON.parse(centerData);
      const zoom = parseInt(mapEl.getAttribute('data-zoom') || '12');

      try {
        const map = L.map(mapId, { preferCanvas: true }).setView(center, zoom);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 19,
          attribution: "&copy; OpenStreetMap contributors",
        }).addTo(map);

        const resp = await fetch(dataUrl);
        const text = await resp.text();

        if (isKml) {
          const parser = new DOMParser();
          const kmlDoc = parser.parseFromString(text, "text/xml");
          const geojson = kml(kmlDoc);
          
          const layer = L.geoJSON(geojson, {
            style: (feature) => {
              if (
                feature.geometry &&
                feature.geometry.type &&
                feature.geometry.type.includes("Line")
              )
                return { color: "crimson", weight: 4 };
              return { color: "#3388ff" };
            },
            onEachFeature: (feature, lyr) => {
              const name =
                feature.properties &&
                (feature.properties.name ||
                  feature.properties.Name ||
                  feature.properties.description);
              if (name) lyr.bindPopup(name);
            },
            pointToLayer: (feature, latlng) =>
              L.circleMarker(latlng, {
                radius: 5,
                fillColor: "#3388ff",
                fillOpacity: 0.9,
                stroke: false,
              }),
          }).addTo(map);

          // comprobaci√≥n segura de bounds
          if (typeof layer.getBounds === "function") {
            const bounds = layer.getBounds();
            if (
              bounds && typeof bounds.isValid === "function"
                ? bounds.isValid()
                : bounds && bounds.isValid !== false
            ) {
              map.fitBounds(bounds);
            }
          }
        } else {
          const geojson = JSON.parse(text);
          const layer = L.geoJSON(geojson).addTo(map);
          if (typeof layer.getBounds === "function") {
            const bounds = layer.getBounds();
            if (
              bounds && typeof bounds.isValid === "function"
                ? bounds.isValid()
                : bounds && bounds.isValid !== false
            ) {
              map.fitBounds(bounds);
            } else {
              map.setView(center, zoom);
            }
          } else {
            map.setView(center, zoom);
          }
        }
      } catch (err) {
        console.error("Error cargando datos del mapa:", err);
      }
    });
  }

  // Run initialization when DOM is ready or immediately if already loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMaps);
  } else {
    initMaps();
  }
</script>
